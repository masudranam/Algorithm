#include<bits/stdc++.h>
using namespace std;
#define int long long
const int M=1e9+7;
const int N=1e5;

int vis[N],col[N];
vector<int> adj[N],radj[N];
int in[N],out[N],size[N],d[N],pr[N],low[N];
int indeg[N],c[N],t=1;
int level[N],table[N][20],p[N];


void dfs(int u=0,int p=-1){
anc[u][0]=p;
for(int i=1;i<19;i++)
    anc[u][i]=~anc[u][i-1]?anc[anc[u][i-1]][i-1]:-1;
for(int v:adj[u]){
    if(v==p)continue;
    d[v]=d[u]+1;
    dfs(v,u);
}
}

int lca(int u,int v){
if(d[u]<d[v])
    swap(u,v);
for(int i=18;~i;i--)
    if(d[u]-(1<<i)>=d[v])
    u=anc[u][i];
if(u==v)
    return u;
for(int i=18;~i;i--)
    if(anc[u][i]^anc[v][i])
    u=anc[u][i],v=anc[v][i];
return anc[u][0];
} 



int lca(int a,int b){
 if(level[a]>level[b])swap(a,b);
 int d=level[b]-level[a];
 while(d--){
    b=p[b];
 }
 if(a==b)return a;
 while(p[a]!=p[b])
        a=p[a],b=p[b];
 return p[a];
}

void lcadfs(int node,int par){
table[node][0]=par;
for(int child:adj[node])
    if(child!=par)
    lcadfs(child,node);
}

void init(){
lcadfs(1,-1);
for(int j=1;j<20;j++){
    for(int i=1;i<=N;i++){
        if(table[i][j-1]!=-1){
            int par=table[i][j-1];
            table[i][j]=table[par][j-1];
        }
    }
}
}


int LCA(int a,int b){
if(level[a]>level[b])swap(a,b);
int d=level[b]-level[a];
while(d){
    int i=log2(d);
    b=table[b][i];
    d-=(1<<i);
}
if(a==b)return a;
for(int i=20;i>=0;i--){
    if(table[a][i]!=-1&& (table[a][i]!=table[b][i])){
        a=table[a][i],b=table[b][i];
    }
}
return p[a];
}


 bool bridge(int u,int p=-1){
     vis[u]=1;
     in[u]=low[u]=t++;
     for(auto v:adj[u]){
        if(v==p)continue;
        if(vis[v]){
            low[u]=min(low[u],in[v]);
        } else{
        if(bridge(v,u))return true;
        if(low[v]>in[u])return true;
        low[u]=min(low[v],low[u]);
        }
     }
     return false;
 }


 void TopSort(int node,int n){
 vector<int> res;
 queue<int> q;
 for(int i=0;i<n;i)if(indeg[i]==0)
    q.push(i);
 while(q.size()){
    int curr=q.front();
    res.push_back(curr);
    q.pop();
    for(int x:adj[curr]){
        indeg[x]--;
        if(indeg[x]==0){
            q.push(x);
        }
    }
 }
 cout<<"Top sort: \n";
 for(auto x: res)cout<<x<<" ";
 }

bool isCycDG(int u=0){
 vis[u]=1;
 for(int v:adj[u]){
    if(!vis[v]){
        if(isCycDG(v))return true;
    }else if(vis[v]==1)return true;
 }
 vis[u]=2;
 return false;
 }

 bool isCycUG(int u=0,int p=-1){
 vis[u]=1;
 for(auto v:adj[u]){
    if(!vis[v]){
        if(isCycUG(v,u))return true;
    } else if(v!=p)return true;
 }
 return false;
 }

 bool isBipart(int u=0,int c=0){
 vis[u]=1;
 col[u]=c;
 for(auto v:adj[u]){
    if(!vis[v]){
        if(!isBipart(v,c^1))return false;
    }else if(col[v]==col[u])return false;
 }
 return true;
 }

 void sp(int src,int dest){
    vis[src]=1;
    pr[src]=-1;
    queue<int> q;
    q.push(src);
    while(!q.empty()){
        int curr=q.front();
        q.pop();
        for(int child: adj[curr]){
            if(vis[child]==0){
                q.push(child);
                d[child]=d[curr]+1;
                pr[child]=curr;
                vis[child]=1;
            }
        }
    }
    if(vis[dest]==0){
        cout<<"No path \n";
    }else{
    vector<int> pth;
    for(int child=dest;child!=-1; child=pr[child]){
        pth.push_back(child);
    }
    reverse(pth.begin(),pth.end());
    cout<<"path dist "<<d[dest]<<":"<<endl;
    for(int x: pth)
        cout<<x<<" ";
    cout<<endl;
    }
 }

 void bfs(int src){
 queue<int> q;
 vis[src]=1;
 q.push(src);
 while(!q.empty()){
    int curr=q.front();
    q.pop();
    cout<<curr<<" ";
    for(int x: adj[curr]){
        if(vis[curr]==0){
            q.push(x);
            vis[x]=1;
        }
    }
 }


 }

int dfss(int node){
  vis[node]=1;
  int curr=1;
  for(int child: adj[node]){
    if(vis[child]==0){
        curr+=dfss(child);
    }
  }
  size[node]=curr;
  return curr;
}

void dfsiot(int node){
vis[node]=1;
in[node]=t++;
for(int child: adj[node]){
    if(vis[child]==0){
        dfsiot(child);
    }
}
out[node]=t++;
}

 void dfs(int node){
 vis[node]=1;
 cout<<node<<" ";
 for(int child: adj[node]){
    if(vis[child]==0)
        dfs(child);
 }
 }

bool dfscd(int node,int par){
vis[node]=1;
for(int child: adj[node]){
    if(vis[child]==0){
        if(dfscd(child,node))
            return true;
        }else{
        if(child!=par)
            return true;
        }
}
return false;
}

void ts(int n){
queue<int> q;
for(int i=0; i<n; i++)
    if(indeg[i]==0)
        q.push(i);
    while(!q.empty()){
        int curr=q.front();
        cout<<curr<<" ";
        q.pop();
        for(int x: adj[curr]){
            indeg[x]--;
            if(indeg[x]==0)
                q.push(x);
        }
    }
}

void dfs(int node,int curr=0){
if(~c[node]){

      if(c[node]^curr){
        cout<<"IMPOSSIBLE\n";
        //exit(0);
        exit(0);
    }
    return;
}
c[node]=curr;
for(int x: adj[node])
    dfs(x,curr^1);

}


vector<array<int,2>>adj1[N];
void diajkstraPQ(int src){
memset(d,0x3f,sizeof(d));
priority_queue<array<int,2>,vector<array<int,2>>,greater<array<int,2>>>q;
d[src]=0;
q.push({0,src});
while(q.size()){
    array<int,2> u=q.top();
    q.pop();
    if(u[0]>d[u[1]])continue;
    for(array<int,2>v:adj1[u[1]]){
        if(d[v[1]]>u[0]+v[0]){
            d[v[1]]=u[0]+v[0];
            q.push({d[v[1]],v[1]});
        }
    }
}

}

void diajkstraSet(int src){
memset(d,0x3f,sizeof(d));
set<array<int,2>>s;
s.insert({d[src]=0,src});
while(s.size()){
    int u=(*s.begin())[1];
    s.erase(s.begin());
    for(auto v: adj1[u]){
        if(d[v[0]]>d[u]+v[0]){
            s.erase({d[v[0]],v[0]});
            d[v[0]]=d[u]+v[0];
            s.insert({d[v[0]],v[0]});
        }
    }
}
}

//kusarajus for strongly connected component
stack<int> s;
 void dfs1(int src){
    vis[src]=1;
    for(int u: adj[src]){
        if(!vis[u])dfs1(u);
    }
    s.push(src);
 }

 void dfs2(int src){
     cout<<src<<" ";
     vis[src]=1;
     for(auto u: radj[src]){
        if(!vis[u])dfs2(u);
     }
 }

 void kusarajus(int n){
 for(int i=0;i<n;i++){
    if(!vis[i])dfs1(i);
 }
 memset(vis,0,sizeof(vis));
 while(s.size()){
    int u=s.top();s.pop();
    if(!vis[u]){
      dfs2(u);
     cout<<endl;
    }
 }
 }

void topo(int n){
for(int i=0;i<n;i++){
    if(!vis[i])dfs1(i);
}
while(s.size()){
    cout<<s.top()<<" ";
    s.pop();
}
cout<<endl;
}

void bfs_0_1(int s,vector<array<int,2>> adj[]){
    memset(d,0x3f,sizeof(d));
    d[s]=0;
    deque<int> q;
    q.push_front(s);
    while(q.size()){
        int u=q.front();q.pop_front();
        for(array<int,2> v: adj[u]){
            if(d[u]+v[1]<d[v[0]]){
                d[v[0]]=d[u]+v[1];
                if(v[1]==1)
                    q.push_back(v[0]);
                else q.push_front(v[0]);
            }
        }
    }
  /*  memset(d,0x3f,sizeof(d));
d[s] = 0;
deque<int> q;
q.push_front(s);
while (!q.empty()) {
    int v = q.front();
    q.pop_front();
    for (auto edge : adj[v]) {
        int u = edge[0];
        int w = edge[1];
        if (d[v] + w < d[u]) {
            d[u] = d[v] + w;
            if (w == 1)
                q.push_back(u);
            else
                q.push_front(u);
        }
    }
}
*/
}

//cycle detection for dirrected graph
vector<int> color,parent;
int cycle_start,cycle_end;
bool dfsc(int v) {
    color[v] = 1;
    for (int u : adj[v]) {
        if (color[u] == 0) {
            parent[u] = v;
            if (dfsc(u))
                return true;
        } else if (color[u] == 1) {
            cycle_end = v;
            cycle_start = u;
            return true;
        }
    }
    color[v] = 2;
    return false;
}

void find_cycle(int n) {
    color.assign(n, 0);
    parent.assign(n, -1);
    cycle_start = -1;

    for (int v = 0; v < n; v++) {
        if (color[v] == 0 && dfsc(v))
            break;
    }

    if (cycle_start == -1) {
        cout << "Acyclic" << endl;
    } else {
        vector<int> cycle;
        cycle.push_back(cycle_start);
        for (int v = cycle_end; v != cycle_start; v = parent[v])
            cycle.push_back(v);
        cycle.push_back(cycle_start);
        reverse(cycle.begin(), cycle.end());

        cout << "Cycle found: ";
        for (int v : cycle)
            cout << v << " ";
        cout << endl;
    }
}

int find(int v){
return v==p[v]?v:p[v]=find(p[v]);
}

void Union(int a,int b){
a=find(a);
b=find(b);
if(a!=b){
    if(size[a]<size[b])swap(a,b);
    p[b]=a;
    size[a]+=size[b];
}
}

 main(void){


}
